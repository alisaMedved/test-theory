1) их надо егко писать и легко читать (например
 dont repit yourself например не всегда соит делать иногдп этот принцип мешает читаемости)
2) обычно юнит тест назван именем файлачто тести
3) а вот e2e именем фичи которую он тестит
4) можнои нужно один файл для утилит и один файл для ттета всех утилит. Утилиты не должны иметь состояние
Это чистые функции
5) файлы экспорта не люблю потому что они мешают тришейкингу
6) Юнитом является та вещь из которой нельзя выдернуть что-то не утратив функциональности. Если мы выдернем 
из компонента хендлер onClick этот хендлер 
утратил свою функциональность (потому что как 
правило он провоцировал или дела изменение 
состояния)

Никогда не пишите бездумно тесты на все методы классового 
компонента - ибо редко тесты всех методов несут бизнес ценность

Особенно это связано с тем что в js не всегда были приватные методы, а во вью они увы невозможны по понятной причине (прокся этому не способствует)

Хрупкость и честность

Тест честный  
1) когда если у него зеленая галочка то проблема модуль ТОЧНО работает
2) и когда у теста красный крестик - то проблема ТОЧНО в ЭТОМ модуле

 1 - недостижимый миф
Так как в кейсах мы учитываем только те кейсы которые видим и продумали - 
обнаружился кейс при котором ломается и этот кейс очевидно не прописан в тесте - 
 ок добавляем его в наш тест

Все внешние зависимости - надо подменять в том числе и ajax запросы


Нехрупкий тест
Если рефакторинг без изменения функциональности не приводит к падению теста
Хрупкий тест это тест который знает слишком много о внутренности; иногда надо остановится и не писать на все внутренние
методы тесты, а написать только на одну большую штуку в которые они входят

Иначе если ты захочешь зарефакторить большую штуку - тебе придется переписыать тест ибо он хрупкий

Если все таки хочется протестить внутренню штуку 
1) она большая важная - ок выноси в отдельный файл/юнит и 
тестть
2) или не пиши на внутреннюю штуку тест
ппррррррррррррр


Подробнее про хрупкость и честность -

честность - мы тесим только то что выходит - то что наш модуль выбрасывает наружу
хрупкость - мы мокаем все что импортируется и вводится в наш модуль

Мы не мокаем все что входит в наш модуль извне - мы не мокаем библиотеку 
и фреимворк; НЕ надо тестить функциональность библиотеки; 

Мы можем не мокать только ту либу которая ведет себя как чистая функция без side 
effects

Фреимворк - он ваш код лергает
либа - вы ее дергайте в своем коде

Чистые наши функции мы можем не мокать -это выбор разработчиков на проекте, но такой выбор встречается часто ибо жизнь сожна. 
Мы верим в покрытие этого нашего модуля

Мы делаем заглушку только если это наш внешний код и либа с побочны эффектом.

history API тоже побочный эффект

Как надо писать тесты чтобы они были нехрупкими и честными?

Arrange Подготовка
Act     Выполнение
Assert  Проверка
Очистка - она не всегда

1) arrange - подготовить все окружени юнита - все что импортируется в юнит замокать, 
компонент если надо создать и т д
2) act - чем короче и чем меньше содержит шагов тем лучше тем менее хрупкий
3) assert - проверить
4) иногда нужно очищать

Вот тут надо сказать две вещи
вещь первая 
иногда бывает так
arrange --> act1 --> assert1 ---> act2 ---> assert2

в ииделе это не правильно и должно быть два теста
тест 1
arrange --> act1 --> assert1 
тест2 
arrange(arrange + act1) --> act2 --> assert2

тут надо понимать что тесты по идеалу написанные быстрее и точнее укажут проблему. но мы понимаем что иногда 
невозможно чтоб настолько растался тестовый файл. Да это осознанное отступление от правил и когда вы отступаете вы дожны принимать риски и неудобства

вторая вещь 
главное чтоюы никогда не повторялась фаза assert - вот это точно допускать нельзя

Виды заглушек 

1) dummy - это просто что-то очень тупое конфигурационное. ну нужна какая-нибудь конфиурация в начале тупо потому что нужна конфигурация и ты ставишь {}
2) fake - это когда реальную вешь извне заменяют вещью-заглушкой упрощенной
например mysql или postgress заменяют sqllite3
3) stub - это настроить чтобы какая-то штука (функция) отвечала определенным образом 
а сейчас мы проверяем что будет если транзакция упала - просим функцию выдасть fail транзакции
4) spy - шпион - регистрирует вызовы какой-либо штуки и ведет их учет - она просто ведет учет и пропускает их через себя не взаймодействуя с ними и не модифицируя ничего внутри сбя
5) mocks - кака]-то штука (функция) должна вызваться с определенными аргументами


Одна из главнейших проблем без лекарства - как гарантировать что stub возвращает то что возвращается 
в реальной жизни по прришествии лет и рефакторингов? никак. Частично спасает typescript.
частично спасает что фреймворки требуют определенные пропсы 


