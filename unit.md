1) их надо егко писать и легко читать (например
 dont repit yourself например не всегда соит делать иногдп этот принцип мешает читаемости)
2) обычно юнит тест назван именем файлачто тести
3) а вот e2e именем фичи которую он тестит
4) можнои нужно один файл для утилит и один файл для ттета всех утилит. Утилиты не должны иметь состояние
Это чистые функции
5) файлы экспорта не люблю потому что они мешают тришейкингу
6) Юнитом является та вещь из которой нельзя выдернуть что-то не утратив функциональности. Если мы выдернем 
из компонента хендлер onClick этот хендлер 
утратил свою функциональность (потому что как 
правило он провоцировал или дела изменение 
состояния)

Никогда не пишите бездумно тесты на все методы классового 
компонента - ибо редко тесты всех методов несут бизнес ценность

Особенно это связано с тем что в js не всегда были приватные методы, а во вью они увы невозможны по понятной причине (прокся этому не способствует)

Хрупкость и честность

Тест честный  
1) когда если у него зеленая галочка то проблема модуль ТОЧНО работает
2) и когда у теста красный крестик - то проблема ТОЧНО в ЭТОМ модуле

 1 - недостижимый миф
Так как в кейсах мы учитываем только те кейсы которые видим и продумали - 
обнаружился кейс при котором ломается и этот кейс очевидно не прописан в тесте - 
 ок добавляем его в наш тест

Все внешние зависимости - надо подменять в том числе и ajax запросы


Нехрупкий тест
Если рефакторинг без изменения функциональности не приводит к падению теста
Хрупкий тест это тест который знает слишком много о внутренности; иногда надо остановится и не писать на все внутренние
методы тесты, а написать только на одну большую штуку в которые они входят

Иначе если ты захочешь зарефакторить большую штуку - тебе придется переписыать тест ибо он хрупкий

Если все таки хочется протестить внутренню штуку 
1) она большая важная - ок выноси в отдельный файл/юнит и 
тестть
2) или не пиши на внутреннюю штуку тест
ппррррррррррррр


Подробнее про хрупкость и честность -

честность - мы тесим только то что выходит - то что наш модуль выбрасывает наружу
хрупкость - мы мокаем все что импортируется и вводится в наш модуль

Мы не мокаем все что входит в наш модуль извне - мы не мокаем библиотеку 
и фреимворк; НЕ надо тестить функциональность библиотеки; 

Мы можем не мокать только ту либу которая ведет себя как чистая функция без side 
effects

Фреимворк - он ваш код лергает
либа - вы ее дергайте в своем коде

Чистые наши функции мы можем не мокать -это выбор разработчиков на проекте, но такой выбор встречается часто ибо жизнь сожна. 
Мы верим в покрытие этого нашего модуля

Мы делаем заглушку только если это наш внешний код и либа с побочны эффектом.

history API тоже побочный эффект

Как надо писать тесты чтобы они были нехрупкими и честными?

Arrange Подготовка
Act     Выполнение
Assert  Проверка
Очистка - она не всегда

1) arrange - подготовить все окружени юнита - все что импортируется в юнит замокать, 
компонент если надо создать и т д
2) act - чем короче и чем меньше содержит шагов тем лучше тем менее хрупкий
3) assert - проверить
4) иногда нужно очищать

Вот тут надо сказать две вещи
вещь первая 
иногда бывает так
arrange --> act1 --> assert1 ---> act2 ---> assert2

в ииделе это не правильно и должно быть два теста
тест 1
arrange --> act1 --> assert1 
тест2 
arrange(arrange + act1) --> act2 --> assert2

тут надо понимать что тесты по идеалу написанные быстрее и точнее укажут проблему. но мы понимаем что иногда 
невозможно чтоб настолько растался тестовый файл. Да это осознанное отступление от правил и когда вы отступаете вы дожны принимать риски и неудобства

вторая вещь 
главное чтоюы никогда не повторялась фаза assert - вот это точно допускать нельзя

Виды заглушек 

1) dummy - это просто что-то очень тупое конфигурационное. ну нужна какая-нибудь конфиурация в начале тупо потому что нужна конфигурация и ты ставишь {}
2) fake - это когда реальную вешь извне заменяют вещью-заглушкой упрощенной
например mysql или postgress заменяют sqllite3
3) stub - это настроить чтобы какая-то штука (функция) отвечала определенным образом 
а сейчас мы проверяем что будет если транзакция упала - просим функцию выдасть fail транзакции
4) spy - шпион - регистрирует вызовы какой-либо штуки и ведет их учет - она просто ведет учет и пропускает их через себя не взаймодействуя с ними и не модифицируя ничего внутри сбя
5) mocks - кака]-то штука (функция) должна вызваться с определенными аргументами


Одна из главнейших проблем без лекарства - как гарантировать что stub возвращает то что возвращается 
в реальной жизни по прришествии лет и рефакторингов? никак. Частично спасает typescript.
частично спасает что фреймворки требуют определенные пропсы 

Фикстуры - это подвид стабов - это стабы, содержащие ответ штуки вне нашей реализации.
Обычный и частый кейс фикстур - это json response ответ с бекенда

А что еали реальный бекенд уже давно не соответствует вашим фикстурам?

1) Типизировать бекенд
GraphQL или кодогенерация от свагера
2) можно прямо скри птом сделать и процемссами получать реальный ответ - записывать его в файл json и использовать его в тестах

Один из главных грехов который допустила и я 
нельзя делать так чтобы выполнение тестов ависело от того в каком порядке их запускать
(у меня так было в рамках одного файла)

TDD - test driven development
Берем ТЗ --> разбиваем его на части/треблования --> 
для кажлого требования пишем тест (убеждаемся что он красный) --> затем
пишем код и тест становится зеленый 

И так скаждым требованием
А потом рефакторим убеждаясь что тест зеленый и в итоге все круто 
Так - даже я понимаю что в реальности так невозможно писать. 

_____

Подход Ильи - отлично - я разрабатываю как Илья. 
Пишем функционал --> пишем на него зеленые тесты --> немного коверкаем функционал туда сюда чтобы тесты стали красными (так мы проверям тесты)
---> и помле рефакторим.

_____

BDD - behaviour driven development
Это отдельный сюр. С маленькой долей все таки хорошего. 
Естть фреймворк Gerhen и на нем можно английскими словами написать тест и потом 
под отдельные слова и словосочетания ты напишешь код. 

Ясен пень что подход BDD это не юниты -исключительно e2e тесты - даже в интеграционные не особо поверю
_____


chai - библиотека для реализации assertion lдля тестового фреимворка mocha
В плане arrange можно познакомится с библиотекой sinon

test double и stub в чем разница?
Хехех пишешь себе на jest и радуешься а тут еще оказывается кто-то юзает отдельный инструмент для импортов в тестах
по имени rewire

test-runner 
1) Запуск параллельно тестов
2) Запуск подмножеств тестов
3) еще и чистить надо после каждого файла
4) плюшки: watch mode - тест один обвалился -ты попровил и охота чтобы только этот тест автоматом перезапустился и проверил
coverage - покрытие сколько строк вашего кода выполнялось вызывалось при запуске теста
интеллект - jest вот например в первую очередь запускает провалившиеся тесты
5) отчеты

Что требуется от utility:

1) насроить окружение
2) отладка тестов
3) сборка - либо вз-ие со  сборщиком либо свой сборщик как в jest - он в обморок 
от импорта css не падает
4) магия - работа с временем

Нельзя свой код менчть ради тестов и часто это происходит так 
If process.env.NODE_ENV === 'test'
ради тестирования времени (это ужасно редко когда оправдано)

ВВедение астрономической секунды завтавило MySQL сожрать сто процентов процессора

JSDOM - это 
 - библиотека, которая анализирует и взаимодействует с собранным HTML так же, как браузер
 - jsdom - это чистая JavaScript-реализация многих веб-стандартов, в частности стандартов WHATWG DOM и HTML, BOM, для использования с Node.js
 - это не настоящий браузер, НО она реализует веб-стандарты так же, как это делают браузеры

Запомним то что тестировать в jsDom бесполезно

- В jsDom нету layout
и потому не получатся штуки с z-index с hidden с тем что спрашивает размер 
offsetwidth clientHeight, scroll with intersectionObserver 

TDD разработала одна компания - у нее были два филиала в Детройте и в Лондоне. 
Различаются концепции тестироаания у них отношениям к заглушкам

То что было выше

 - Мы не мокаем все что входит в наш модуль извне нашего приложения - 
 мы не мокаем библиотеку и фреимворк; НЕ надо тестить функциональность 
 библиотеки; 

 - Мы можем не мокать только ту либу которая ведет себя как чистая 
 функция без side effects 
 
- При этом Мы делаем заглушку только если это наш внешний код и 
либа с побочны эффектом history API тоже побочный эффект

Детройт или Классицисты: максимально ничего не мокать (даже если есть побочный эффект)
и мокать только то что является уж очень опасным (неохота во время теста делать реальную оаплату)

Лондон или Мокисты: мокаем все что не является чистым 

Класика
Плюсы:
1) не болеют ложными моками
2) ближе к реальности
3) шире покрытие - если честно их тесты это тесты 
больше интеграционнные получаются
4) Нету желания/ времени разбираться в системе - юзай класссику

Проблемы/минусы: 
1) черт придется придумать как мокать компонент и тестить относительно не VOM
а html 
shallowRender

Мокисты 
Плюсы:
1) антихрупкие и честные тесты
За классику enzyme за мокистов react testing library 

Истина посередине

____

Рофлы продолжаются
компонентное тестирование - это суровая реальность между юнитами и интеграционными. 
Если честно я раньше это чуствовала - рада что Илья об этом говорит.

Компромис между чистотой юниов и практической пользой интеграционнных
Первая боль вью: methods содержит вызовы и обращения не только
того что внутри и относится к компоненту но и ко внешнему например
this.$modal.show

Мы должны тестировать только поведение компонентов
А поведение это:

- html

- emit

- вызовы внешних сущностей (почти 99 процентов это вызовы к апи и стору)

Во время тестов мы должны оказывать только следующие воздействия:
- props изменять
- события в компонент присылать
- изменять внешнее состояние (изменять данные в сторе)

Категорически запрещено:
1) присваивать что-нибудь полям компонента - менять состояние компонента
компонент C 
C.users = []
Нельзя! users это личное дело компонента 
2) нельзя тестить computed . Хотите протестить ибо там сложная логика? Выносите в отдельный файл и тестрируйте как чистую функцию

То есть тестирование компонента - должно быть тестированием черного ящика

Дальше речь идет про vue-test-utils

vue-test-utils по мнению BИльи не очень удачная либа и вообщемногое в ней написано странно. 
Но пока по тому что он рассказывает мне это немного напоминае react testing library

Поехали у React все достаточно просто - есть пропсы на входе и на выходе html

У вью веселее
Есть на входе props, emits, provide/inject, slots, 
а еще директивы глобальные Vue.use и на выходе html

Но эта либа понятное дело работает с VOM
Под капотом она оборачивает компонент в parrent component и все эти входные параметры становятся data 
parrent component-а.

А теперь похожее на react testing library 
mount - рендерится все дерево со всеми детьми
shallowMount - рендерится только дети первого порядка и то они представлены заглушками

И тут есть забавные возмдности
в stubs можно указывать что рендерить заглушками при mount, а что рендерить прям настоящими компонентами
при shallowMount. 

Итак плюсы и минусы подходов shallowMount и mount

mount:
плюсы
1) при малом колисчестве тестов больше покрытие - по сути это уже приближается к интеграционным тестам тесты компонентов при таком подходе
2) легче протестить сценарии именно с точки зрения пользователя - прям с html взайможействуя будто

минусы
1) круто тестить только положительные кейсы, а вот как прописать отрицательные - ой бля
2) тесты нечестные: проблема в реенке ребенка а упал тест этого компонента
3) не тестится так хорошо контракт компонента что на входе и что на выходе
4) а теперь бери и настрой то окружение которое устроит всех детей (кто-то из детей юзает vuex
а тестируемый компонент - нет - ничего не знаем, подрубай окружение для vuex)


shallowMount:
плюсы
1) отлично тестится контракт компонента
2) тесты честные и нехрупкие
минусы
1) заглушки компонентов могут перестать соответсвовать реальности 
а тест зеленый - эта вечная проблема несоответсвия stub реальности

Дальше плюсы и минусы переворачивай

Илья не верит в крутость подхода mount на средних и больших проектах - ну наверно он прав
я правда не знаю как быть с пользовательскими сценариями

В принципе я согласна с Ильей. Пусть будут честные тесты на shallowMount для малых компонентов
А потом когда тестишь большой и с крупной длогикой и со всеми этими детьми 
то тестить с помощью mount, но подписываешь этот тест как интеграционный.


1) нельзя писать тесты при которых ты каждый раз переиспользуешь компонент меняя и накопливая состояние
из теста в тест - минимально накопленное окружение
2) setProps for watcher tests
3) setUp - кастомные composable тестить наверно как функции, а вот сетапы которые
4) влияют на компонент - это не тестить - это чисто внутренние дела компонента